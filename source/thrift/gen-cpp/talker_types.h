/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef talker_TYPES_H
#define talker_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace kiwi {

struct ErrorCode {
  enum type {
    ILLEGAL_ARGUMENT = 0,
    AUTHENTICATION_FAILED = 1,
    DB_FAILED = 2,
    INVALID_STATE = 3,
    EXCESSIVE_ACCESS = 4,
    NOT_FOUND = 5,
    INVALID_LENGTH = 6,
    NOT_AVAILABLE_USER = 7,
    NOT_AUTHORIZED_DEVICE = 8,
    INVALID_MID = 9,
    NOT_A_MEMBER = 10,
    INCOMPATIBLE_APP_VERSION = 11,
    NOT_READY = 12,
    NOT_AVAILABLE_SESSION = 13,
    NOT_AUTHORIZED_SESSION = 14,
    SYSTEM_ERROR = 15,
    NO_AVAILABLE_VERIFICATION_METHOD = 16,
    NOT_AUTHENTICATED = 17,
    INVALID_IDENTITY_CREDENTIAL = 18,
    NOT_AVAILABLE_IDENTITY_IDENTIFIER = 19,
    INTERNAL_ERROR = 20,
    NO_SUCH_IDENTITY_IDENFIER = 21,
    DEACTIVATED_ACCOUNT_BOUND_TO_THIS_IDENTITY = 22,
    ILLEGAL_IDENTITY_CREDENTIAL = 23,
    UNKNOWN_CHANNEL = 24,
    NO_SUCH_MESSAGE_BOX = 25,
    NOT_AVAILABLE_MESSAGE_BOX = 26,
    CHANNEL_DOES_NOT_MATCH = 27,
    NOT_YOUR_MESSAGE = 28,
    MESSAGE_DEFINED_ERROR = 29,
    USER_CANNOT_ACCEPT_PRESENTS = 30,
    USER_NOT_STICKER_OWNER = 32,
    MAINTENANCE_ERROR = 33,
    ACCOUNT_NOT_MATCHED = 34,
    ABUSE_BLOCK = 35,
    NOT_FRIEND = 36,
    NOT_ALLOWED_CALL = 37,
    BLOCK_FRIEND = 38,
    INCOMPATIBLE_VOIP_VERSION = 39,
    INVALID_SNS_ACCESS_TOKEN = 40,
    EXTERNAL_SERVICE_NOT_AVAILABLE = 41,
    NOT_ALLOWED_ADD_CONTACT = 42,
    NOT_CERTIFICATED = 43,
    NOT_ALLOWED_SECONDARY_DEVICE = 44,
    INVALID_PIN_CODE = 45,
    NOT_FOUND_IDENTITY_CREDENTIAL = 46,
    EXCEED_FILE_MAX_SIZE = 47,
    EXCEED_DAILY_QUOTA = 48,
    NOT_SUPPORT_SEND_FILE = 49,
    MUST_UPGRADE = 50,
    NOT_AVAILABLE_PIN_CODE_SESSION = 51
  };
};

extern const std::map<int, const char*> _ErrorCode_VALUES_TO_NAMES;

struct NotificationType {
  enum type {
    APPLE_APNS = 1,
    GOOGLE_C2DM = 2,
    NHN_NNI = 3,
    SKT_AOM = 4,
    MS_MPNS = 5,
    RIM_BIS = 6,
    GOOGLE_GCM = 7,
    NOKIA_NNAPI = 8,
    TIZEN = 9
  };
};

extern const std::map<int, const char*> _NotificationType_VALUES_TO_NAMES;

struct ShipType {
  enum type {
    RESERVED = 0,
    CONNECT = 1,
    PUBLISH = 2,
    SUBSCRIBE = 3,
    DISCONNECT = 4,
    TEXT = 16,
    TEXTURE = 10,
    ACTION = 26,
    PICTURE = 42,
    ANIMATION = 58,
    VOICE = 74,
    LOCATION = 90
  };
};

extern const std::map<int, const char*> _ShipType_VALUES_TO_NAMES;

struct Response {
  enum type {
    ACCEPTED = 10,
    REFUSE = 26
  };
};

extern const std::map<int, const char*> _Response_VALUES_TO_NAMES;

typedef std::vector<class ServiceInfo>  ServiceList;

class ServiceInfo;

class Location;

class Ship;

class NotFoundException;

class InvalidRequestException;

class UnavailableException;

class TimedOutException;

class RequestException;

typedef struct _ServiceInfo__isset {
  _ServiceInfo__isset() : ServiceName(false), AliasName(false), HostName(false), Version(false), ServicePort(false), Onlines(false) {}
  bool ServiceName :1;
  bool AliasName :1;
  bool HostName :1;
  bool Version :1;
  bool ServicePort :1;
  bool Onlines :1;
} _ServiceInfo__isset;

class ServiceInfo {
 public:

  ServiceInfo(const ServiceInfo&);
  ServiceInfo& operator=(const ServiceInfo&);
  ServiceInfo() : ServiceName(), AliasName(), HostName(), Version(), ServicePort(0), Onlines(0) {
  }

  virtual ~ServiceInfo() throw();
  std::string ServiceName;
  std::string AliasName;
  std::string HostName;
  std::string Version;
  int32_t ServicePort;
  int32_t Onlines;

  _ServiceInfo__isset __isset;

  void __set_ServiceName(const std::string& val);

  void __set_AliasName(const std::string& val);

  void __set_HostName(const std::string& val);

  void __set_Version(const std::string& val);

  void __set_ServicePort(const int32_t val);

  void __set_Onlines(const int32_t val);

  bool operator == (const ServiceInfo & rhs) const
  {
    if (!(ServiceName == rhs.ServiceName))
      return false;
    if (!(AliasName == rhs.AliasName))
      return false;
    if (!(HostName == rhs.HostName))
      return false;
    if (!(Version == rhs.Version))
      return false;
    if (!(ServicePort == rhs.ServicePort))
      return false;
    if (!(Onlines == rhs.Onlines))
      return false;
    return true;
  }
  bool operator != (const ServiceInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ServiceInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ServiceInfo &a, ServiceInfo &b);

inline std::ostream& operator<<(std::ostream& out, const ServiceInfo& obj)
{
  obj.printTo(out);
  return out;
}


class Location {
 public:

  Location(const Location&);
  Location& operator=(const Location&);
  Location() : latitude(0), longitude(0) {
  }

  virtual ~Location() throw();
  double latitude;
  double longitude;

  void __set_latitude(const double val);

  void __set_longitude(const double val);

  bool operator == (const Location & rhs) const
  {
    if (!(latitude == rhs.latitude))
      return false;
    if (!(longitude == rhs.longitude))
      return false;
    return true;
  }
  bool operator != (const Location &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Location & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Location &a, Location &b);

inline std::ostream& operator<<(std::ostream& out, const Location& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Ship__isset {
  _Ship__isset() : shipId(false), text(false), picture(false), animation(false), loc(false), action(false), texId(false) {}
  bool shipId :1;
  bool text :1;
  bool picture :1;
  bool animation :1;
  bool loc :1;
  bool action :1;
  bool texId :1;
} _Ship__isset;

class Ship {
 public:

  Ship(const Ship&);
  Ship& operator=(const Ship&);
  Ship() : userId(), nickName(), shipType((ShipType::type)16), timeStamp(0), shipId(0), text(), picture(), animation(), action(), texId() {
    shipType = (ShipType::type)16;

  }

  virtual ~Ship() throw();
  std::string userId;
  std::string nickName;
  ShipType::type shipType;
  int32_t timeStamp;
  int32_t shipId;
  std::string text;
  std::string picture;
  std::string animation;
  Location loc;
  std::string action;
  std::string texId;

  _Ship__isset __isset;

  void __set_userId(const std::string& val);

  void __set_nickName(const std::string& val);

  void __set_shipType(const ShipType::type val);

  void __set_timeStamp(const int32_t val);

  void __set_shipId(const int32_t val);

  void __set_text(const std::string& val);

  void __set_picture(const std::string& val);

  void __set_animation(const std::string& val);

  void __set_loc(const Location& val);

  void __set_action(const std::string& val);

  void __set_texId(const std::string& val);

  bool operator == (const Ship & rhs) const
  {
    if (!(userId == rhs.userId))
      return false;
    if (!(nickName == rhs.nickName))
      return false;
    if (!(shipType == rhs.shipType))
      return false;
    if (!(timeStamp == rhs.timeStamp))
      return false;
    if (__isset.shipId != rhs.__isset.shipId)
      return false;
    else if (__isset.shipId && !(shipId == rhs.shipId))
      return false;
    if (__isset.text != rhs.__isset.text)
      return false;
    else if (__isset.text && !(text == rhs.text))
      return false;
    if (__isset.picture != rhs.__isset.picture)
      return false;
    else if (__isset.picture && !(picture == rhs.picture))
      return false;
    if (__isset.animation != rhs.__isset.animation)
      return false;
    else if (__isset.animation && !(animation == rhs.animation))
      return false;
    if (__isset.loc != rhs.__isset.loc)
      return false;
    else if (__isset.loc && !(loc == rhs.loc))
      return false;
    if (__isset.action != rhs.__isset.action)
      return false;
    else if (__isset.action && !(action == rhs.action))
      return false;
    if (__isset.texId != rhs.__isset.texId)
      return false;
    else if (__isset.texId && !(texId == rhs.texId))
      return false;
    return true;
  }
  bool operator != (const Ship &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Ship & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Ship &a, Ship &b);

inline std::ostream& operator<<(std::ostream& out, const Ship& obj)
{
  obj.printTo(out);
  return out;
}


class NotFoundException : public ::apache::thrift::TException {
 public:

  NotFoundException(const NotFoundException&);
  NotFoundException& operator=(const NotFoundException&);
  NotFoundException() {
  }

  virtual ~NotFoundException() throw();

  bool operator == (const NotFoundException & /* rhs */) const
  {
    return true;
  }
  bool operator != (const NotFoundException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NotFoundException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(NotFoundException &a, NotFoundException &b);

inline std::ostream& operator<<(std::ostream& out, const NotFoundException& obj)
{
  obj.printTo(out);
  return out;
}


class InvalidRequestException : public ::apache::thrift::TException {
 public:

  InvalidRequestException(const InvalidRequestException&);
  InvalidRequestException& operator=(const InvalidRequestException&);
  InvalidRequestException() : why() {
  }

  virtual ~InvalidRequestException() throw();
  std::string why;

  void __set_why(const std::string& val);

  bool operator == (const InvalidRequestException & rhs) const
  {
    if (!(why == rhs.why))
      return false;
    return true;
  }
  bool operator != (const InvalidRequestException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidRequestException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(InvalidRequestException &a, InvalidRequestException &b);

inline std::ostream& operator<<(std::ostream& out, const InvalidRequestException& obj)
{
  obj.printTo(out);
  return out;
}


class UnavailableException : public ::apache::thrift::TException {
 public:

  UnavailableException(const UnavailableException&);
  UnavailableException& operator=(const UnavailableException&);
  UnavailableException() {
  }

  virtual ~UnavailableException() throw();

  bool operator == (const UnavailableException & /* rhs */) const
  {
    return true;
  }
  bool operator != (const UnavailableException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UnavailableException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(UnavailableException &a, UnavailableException &b);

inline std::ostream& operator<<(std::ostream& out, const UnavailableException& obj)
{
  obj.printTo(out);
  return out;
}


class TimedOutException : public ::apache::thrift::TException {
 public:

  TimedOutException(const TimedOutException&);
  TimedOutException& operator=(const TimedOutException&);
  TimedOutException() {
  }

  virtual ~TimedOutException() throw();

  bool operator == (const TimedOutException & /* rhs */) const
  {
    return true;
  }
  bool operator != (const TimedOutException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TimedOutException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(TimedOutException &a, TimedOutException &b);

inline std::ostream& operator<<(std::ostream& out, const TimedOutException& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _RequestException__isset {
  _RequestException__isset() : code(false), why(false), parameterMap(false) {}
  bool code :1;
  bool why :1;
  bool parameterMap :1;
} _RequestException__isset;

class RequestException : public ::apache::thrift::TException {
 public:

  RequestException(const RequestException&);
  RequestException& operator=(const RequestException&);
  RequestException() : code((ErrorCode::type)0), why() {
  }

  virtual ~RequestException() throw();
  ErrorCode::type code;
  std::string why;
  std::map<std::string, std::string>  parameterMap;

  _RequestException__isset __isset;

  void __set_code(const ErrorCode::type val);

  void __set_why(const std::string& val);

  void __set_parameterMap(const std::map<std::string, std::string> & val);

  bool operator == (const RequestException & rhs) const
  {
    if (!(code == rhs.code))
      return false;
    if (!(why == rhs.why))
      return false;
    if (!(parameterMap == rhs.parameterMap))
      return false;
    return true;
  }
  bool operator != (const RequestException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RequestException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(RequestException &a, RequestException &b);

inline std::ostream& operator<<(std::ostream& out, const RequestException& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
