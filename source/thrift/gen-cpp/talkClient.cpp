/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "talkClient.h"

namespace kiwi {


talkClient_on_getVersion_args::~talkClient_on_getVersion_args() throw() {
}


uint32_t talkClient_on_getVersion_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t talkClient_on_getVersion_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("talkClient_on_getVersion_args");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


talkClient_on_getVersion_pargs::~talkClient_on_getVersion_pargs() throw() {
}


uint32_t talkClient_on_getVersion_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("talkClient_on_getVersion_pargs");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->version)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


talkClient_on_getVersion_failed_args::~talkClient_on_getVersion_failed_args() throw() {
}


uint32_t talkClient_on_getVersion_failed_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_why = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          isset_why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_why)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t talkClient_on_getVersion_failed_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("talkClient_on_getVersion_failed_args");

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


talkClient_on_getVersion_failed_pargs::~talkClient_on_getVersion_failed_pargs() throw() {
}


uint32_t talkClient_on_getVersion_failed_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("talkClient_on_getVersion_failed_pargs");

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->why)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


talkClient_on_setUserName_succeeded_args::~talkClient_on_setUserName_succeeded_args() throw() {
}


uint32_t talkClient_on_setUserName_succeeded_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_userId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->userId);
          isset_userId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_userId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t talkClient_on_setUserName_succeeded_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("talkClient_on_setUserName_succeeded_args");

  xfer += oprot->writeFieldBegin("userId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->userId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


talkClient_on_setUserName_succeeded_pargs::~talkClient_on_setUserName_succeeded_pargs() throw() {
}


uint32_t talkClient_on_setUserName_succeeded_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("talkClient_on_setUserName_succeeded_pargs");

  xfer += oprot->writeFieldBegin("userId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->userId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


talkClient_on_setUserName_failed_args::~talkClient_on_setUserName_failed_args() throw() {
}


uint32_t talkClient_on_setUserName_failed_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_why = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          isset_why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_why)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t talkClient_on_setUserName_failed_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("talkClient_on_setUserName_failed_args");

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


talkClient_on_setUserName_failed_pargs::~talkClient_on_setUserName_failed_pargs() throw() {
}


uint32_t talkClient_on_setUserName_failed_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("talkClient_on_setUserName_failed_pargs");

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->why)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


talkClient_on_subscribe_args::~talkClient_on_subscribe_args() throw() {
}


uint32_t talkClient_on_subscribe_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_topicId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->topicId);
          isset_topicId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_topicId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t talkClient_on_subscribe_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("talkClient_on_subscribe_args");

  xfer += oprot->writeFieldBegin("topicId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->topicId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


talkClient_on_subscribe_pargs::~talkClient_on_subscribe_pargs() throw() {
}


uint32_t talkClient_on_subscribe_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("talkClient_on_subscribe_pargs");

  xfer += oprot->writeFieldBegin("topicId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->topicId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


talkClient_on_subscribe_failed_args::~talkClient_on_subscribe_failed_args() throw() {
}


uint32_t talkClient_on_subscribe_failed_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_why = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          isset_why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_why)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t talkClient_on_subscribe_failed_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("talkClient_on_subscribe_failed_args");

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


talkClient_on_subscribe_failed_pargs::~talkClient_on_subscribe_failed_pargs() throw() {
}


uint32_t talkClient_on_subscribe_failed_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("talkClient_on_subscribe_failed_pargs");

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->why)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


talkClient_on_unsubscribe_succeeded_args::~talkClient_on_unsubscribe_succeeded_args() throw() {
}


uint32_t talkClient_on_unsubscribe_succeeded_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t talkClient_on_unsubscribe_succeeded_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("talkClient_on_unsubscribe_succeeded_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


talkClient_on_unsubscribe_succeeded_pargs::~talkClient_on_unsubscribe_succeeded_pargs() throw() {
}


uint32_t talkClient_on_unsubscribe_succeeded_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("talkClient_on_unsubscribe_succeeded_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


talkClient_on_unsubscribe_failed_args::~talkClient_on_unsubscribe_failed_args() throw() {
}


uint32_t talkClient_on_unsubscribe_failed_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_why = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          isset_why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_why)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t talkClient_on_unsubscribe_failed_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("talkClient_on_unsubscribe_failed_args");

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


talkClient_on_unsubscribe_failed_pargs::~talkClient_on_unsubscribe_failed_pargs() throw() {
}


uint32_t talkClient_on_unsubscribe_failed_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("talkClient_on_unsubscribe_failed_pargs");

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->why)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


talkClient_on_subscribeShip_args::~talkClient_on_subscribeShip_args() throw() {
}


uint32_t talkClient_on_subscribeShip_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_ship = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ship.read(iprot);
          isset_ship = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ship)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t talkClient_on_subscribeShip_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("talkClient_on_subscribeShip_args");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ship", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->ship.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


talkClient_on_subscribeShip_pargs::~talkClient_on_subscribeShip_pargs() throw() {
}


uint32_t talkClient_on_subscribeShip_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("talkClient_on_subscribeShip_pargs");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->name)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ship", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->ship)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


talkClient_on_subscribeShip_failed_args::~talkClient_on_subscribeShip_failed_args() throw() {
}


uint32_t talkClient_on_subscribeShip_failed_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_why = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          isset_why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_why)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t talkClient_on_subscribeShip_failed_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("talkClient_on_subscribeShip_failed_args");

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


talkClient_on_subscribeShip_failed_pargs::~talkClient_on_subscribeShip_failed_pargs() throw() {
}


uint32_t talkClient_on_subscribeShip_failed_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("talkClient_on_subscribeShip_failed_pargs");

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->why)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void talkClientClient::on_getVersion(const std::string& version)
{
  send_on_getVersion(version);
}

void talkClientClient::send_on_getVersion(const std::string& version)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("on_getVersion", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  talkClient_on_getVersion_pargs args;
  args.version = &version;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void talkClientClient::on_getVersion_failed(const std::string& why)
{
  send_on_getVersion_failed(why);
}

void talkClientClient::send_on_getVersion_failed(const std::string& why)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("on_getVersion_failed", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  talkClient_on_getVersion_failed_pargs args;
  args.why = &why;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void talkClientClient::on_setUserName_succeeded(const int64_t userId)
{
  send_on_setUserName_succeeded(userId);
}

void talkClientClient::send_on_setUserName_succeeded(const int64_t userId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("on_setUserName_succeeded", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  talkClient_on_setUserName_succeeded_pargs args;
  args.userId = &userId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void talkClientClient::on_setUserName_failed(const std::string& why)
{
  send_on_setUserName_failed(why);
}

void talkClientClient::send_on_setUserName_failed(const std::string& why)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("on_setUserName_failed", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  talkClient_on_setUserName_failed_pargs args;
  args.why = &why;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void talkClientClient::on_subscribe(const int64_t topicId)
{
  send_on_subscribe(topicId);
}

void talkClientClient::send_on_subscribe(const int64_t topicId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("on_subscribe", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  talkClient_on_subscribe_pargs args;
  args.topicId = &topicId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void talkClientClient::on_subscribe_failed(const std::string& why)
{
  send_on_subscribe_failed(why);
}

void talkClientClient::send_on_subscribe_failed(const std::string& why)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("on_subscribe_failed", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  talkClient_on_subscribe_failed_pargs args;
  args.why = &why;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void talkClientClient::on_unsubscribe_succeeded()
{
  send_on_unsubscribe_succeeded();
}

void talkClientClient::send_on_unsubscribe_succeeded()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("on_unsubscribe_succeeded", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  talkClient_on_unsubscribe_succeeded_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void talkClientClient::on_unsubscribe_failed(const std::string& why)
{
  send_on_unsubscribe_failed(why);
}

void talkClientClient::send_on_unsubscribe_failed(const std::string& why)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("on_unsubscribe_failed", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  talkClient_on_unsubscribe_failed_pargs args;
  args.why = &why;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void talkClientClient::on_subscribeShip(const std::string& name, const Ship& ship)
{
  send_on_subscribeShip(name, ship);
}

void talkClientClient::send_on_subscribeShip(const std::string& name, const Ship& ship)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("on_subscribeShip", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  talkClient_on_subscribeShip_pargs args;
  args.name = &name;
  args.ship = &ship;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void talkClientClient::on_subscribeShip_failed(const std::string& why)
{
  send_on_subscribeShip_failed(why);
}

void talkClientClient::send_on_subscribeShip_failed(const std::string& why)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("on_subscribeShip_failed", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  talkClient_on_subscribeShip_failed_pargs args;
  args.why = &why;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool talkClientProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void talkClientProcessor::process_on_getVersion(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("talkClient.on_getVersion", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "talkClient.on_getVersion");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "talkClient.on_getVersion");
  }

  talkClient_on_getVersion_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "talkClient.on_getVersion", bytes);
  }

  try {
    iface_->on_getVersion(args.version);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "talkClient.on_getVersion");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "talkClient.on_getVersion");
  }

  return;
}

void talkClientProcessor::process_on_getVersion_failed(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("talkClient.on_getVersion_failed", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "talkClient.on_getVersion_failed");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "talkClient.on_getVersion_failed");
  }

  talkClient_on_getVersion_failed_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "talkClient.on_getVersion_failed", bytes);
  }

  try {
    iface_->on_getVersion_failed(args.why);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "talkClient.on_getVersion_failed");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "talkClient.on_getVersion_failed");
  }

  return;
}

void talkClientProcessor::process_on_setUserName_succeeded(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("talkClient.on_setUserName_succeeded", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "talkClient.on_setUserName_succeeded");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "talkClient.on_setUserName_succeeded");
  }

  talkClient_on_setUserName_succeeded_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "talkClient.on_setUserName_succeeded", bytes);
  }

  try {
    iface_->on_setUserName_succeeded(args.userId);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "talkClient.on_setUserName_succeeded");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "talkClient.on_setUserName_succeeded");
  }

  return;
}

void talkClientProcessor::process_on_setUserName_failed(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("talkClient.on_setUserName_failed", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "talkClient.on_setUserName_failed");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "talkClient.on_setUserName_failed");
  }

  talkClient_on_setUserName_failed_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "talkClient.on_setUserName_failed", bytes);
  }

  try {
    iface_->on_setUserName_failed(args.why);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "talkClient.on_setUserName_failed");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "talkClient.on_setUserName_failed");
  }

  return;
}

void talkClientProcessor::process_on_subscribe(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("talkClient.on_subscribe", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "talkClient.on_subscribe");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "talkClient.on_subscribe");
  }

  talkClient_on_subscribe_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "talkClient.on_subscribe", bytes);
  }

  try {
    iface_->on_subscribe(args.topicId);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "talkClient.on_subscribe");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "talkClient.on_subscribe");
  }

  return;
}

void talkClientProcessor::process_on_subscribe_failed(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("talkClient.on_subscribe_failed", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "talkClient.on_subscribe_failed");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "talkClient.on_subscribe_failed");
  }

  talkClient_on_subscribe_failed_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "talkClient.on_subscribe_failed", bytes);
  }

  try {
    iface_->on_subscribe_failed(args.why);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "talkClient.on_subscribe_failed");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "talkClient.on_subscribe_failed");
  }

  return;
}

void talkClientProcessor::process_on_unsubscribe_succeeded(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("talkClient.on_unsubscribe_succeeded", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "talkClient.on_unsubscribe_succeeded");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "talkClient.on_unsubscribe_succeeded");
  }

  talkClient_on_unsubscribe_succeeded_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "talkClient.on_unsubscribe_succeeded", bytes);
  }

  try {
    iface_->on_unsubscribe_succeeded();
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "talkClient.on_unsubscribe_succeeded");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "talkClient.on_unsubscribe_succeeded");
  }

  return;
}

void talkClientProcessor::process_on_unsubscribe_failed(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("talkClient.on_unsubscribe_failed", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "talkClient.on_unsubscribe_failed");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "talkClient.on_unsubscribe_failed");
  }

  talkClient_on_unsubscribe_failed_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "talkClient.on_unsubscribe_failed", bytes);
  }

  try {
    iface_->on_unsubscribe_failed(args.why);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "talkClient.on_unsubscribe_failed");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "talkClient.on_unsubscribe_failed");
  }

  return;
}

void talkClientProcessor::process_on_subscribeShip(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("talkClient.on_subscribeShip", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "talkClient.on_subscribeShip");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "talkClient.on_subscribeShip");
  }

  talkClient_on_subscribeShip_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "talkClient.on_subscribeShip", bytes);
  }

  try {
    iface_->on_subscribeShip(args.name, args.ship);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "talkClient.on_subscribeShip");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "talkClient.on_subscribeShip");
  }

  return;
}

void talkClientProcessor::process_on_subscribeShip_failed(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("talkClient.on_subscribeShip_failed", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "talkClient.on_subscribeShip_failed");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "talkClient.on_subscribeShip_failed");
  }

  talkClient_on_subscribeShip_failed_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "talkClient.on_subscribeShip_failed", bytes);
  }

  try {
    iface_->on_subscribeShip_failed(args.why);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "talkClient.on_subscribeShip_failed");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "talkClient.on_subscribeShip_failed");
  }

  return;
}

::boost::shared_ptr< ::apache::thrift::TProcessor > talkClientProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< talkClientIfFactory > cleanup(handlerFactory_);
  ::boost::shared_ptr< talkClientIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::boost::shared_ptr< ::apache::thrift::TProcessor > processor(new talkClientProcessor(handler));
  return processor;
}

void talkClientConcurrentClient::on_getVersion(const std::string& version)
{
  send_on_getVersion(version);
}

void talkClientConcurrentClient::send_on_getVersion(const std::string& version)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("on_getVersion", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  talkClient_on_getVersion_pargs args;
  args.version = &version;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void talkClientConcurrentClient::on_getVersion_failed(const std::string& why)
{
  send_on_getVersion_failed(why);
}

void talkClientConcurrentClient::send_on_getVersion_failed(const std::string& why)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("on_getVersion_failed", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  talkClient_on_getVersion_failed_pargs args;
  args.why = &why;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void talkClientConcurrentClient::on_setUserName_succeeded(const int64_t userId)
{
  send_on_setUserName_succeeded(userId);
}

void talkClientConcurrentClient::send_on_setUserName_succeeded(const int64_t userId)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("on_setUserName_succeeded", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  talkClient_on_setUserName_succeeded_pargs args;
  args.userId = &userId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void talkClientConcurrentClient::on_setUserName_failed(const std::string& why)
{
  send_on_setUserName_failed(why);
}

void talkClientConcurrentClient::send_on_setUserName_failed(const std::string& why)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("on_setUserName_failed", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  talkClient_on_setUserName_failed_pargs args;
  args.why = &why;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void talkClientConcurrentClient::on_subscribe(const int64_t topicId)
{
  send_on_subscribe(topicId);
}

void talkClientConcurrentClient::send_on_subscribe(const int64_t topicId)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("on_subscribe", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  talkClient_on_subscribe_pargs args;
  args.topicId = &topicId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void talkClientConcurrentClient::on_subscribe_failed(const std::string& why)
{
  send_on_subscribe_failed(why);
}

void talkClientConcurrentClient::send_on_subscribe_failed(const std::string& why)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("on_subscribe_failed", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  talkClient_on_subscribe_failed_pargs args;
  args.why = &why;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void talkClientConcurrentClient::on_unsubscribe_succeeded()
{
  send_on_unsubscribe_succeeded();
}

void talkClientConcurrentClient::send_on_unsubscribe_succeeded()
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("on_unsubscribe_succeeded", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  talkClient_on_unsubscribe_succeeded_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void talkClientConcurrentClient::on_unsubscribe_failed(const std::string& why)
{
  send_on_unsubscribe_failed(why);
}

void talkClientConcurrentClient::send_on_unsubscribe_failed(const std::string& why)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("on_unsubscribe_failed", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  talkClient_on_unsubscribe_failed_pargs args;
  args.why = &why;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void talkClientConcurrentClient::on_subscribeShip(const std::string& name, const Ship& ship)
{
  send_on_subscribeShip(name, ship);
}

void talkClientConcurrentClient::send_on_subscribeShip(const std::string& name, const Ship& ship)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("on_subscribeShip", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  talkClient_on_subscribeShip_pargs args;
  args.name = &name;
  args.ship = &ship;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void talkClientConcurrentClient::on_subscribeShip_failed(const std::string& why)
{
  send_on_subscribeShip_failed(why);
}

void talkClientConcurrentClient::send_on_subscribeShip_failed(const std::string& why)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("on_subscribeShip_failed", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  talkClient_on_subscribeShip_failed_pargs args;
  args.why = &why;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

} // namespace

